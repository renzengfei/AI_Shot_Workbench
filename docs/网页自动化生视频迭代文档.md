# 网页自动化生视频迭代文档

## 实现计划

### Phase 1：基础设施（预计 2 天）

- [ ] **1.1 邮箱系统搭建**
  - 购买域名，配置 Cloudflare Email Routing Catch-All
  - 设置 Gmail IMAP 转发
  - 测试验证码接收

- [ ] **1.2 账号池初始化**
  - 创建 `backend/automation/account_pool.py`
  - 实现 `generate_accounts()` 生成 50-100 个账号配置
  - 实现 `AccountPool` 类（加载/保存/获取可用账号/标记使用）

- [ ] **1.3 邮件接收器**
  - 创建 `backend/automation/email_receiver.py`
  - 实现 IMAP 连接和验证码提取
  - 测试 Lovart.ai 验证码邮件格式

### Phase 2：自动化核心（预计 3 天）

- [ ] **2.1 指纹浏览器**
  - 创建 `backend/automation/fingerprint_browser.py`
  - 实现 `AsyncFingerprintBrowser` 类
  - 测试指纹注入效果

- [ ] **2.2 Lovart.ai 自动化**
  - 创建 `backend/automation/lovart_automation.py`
  - 实现 `login_or_register()` 登录/注册流程
  - 实现 `generate_video_single()` 单次视频生成
  - 实现 `generate_videos_for_shot()` 并行生成

- [ ] **2.3 批量注册工具**
  - 创建 `backend/automation/batch_register.py`
  - 实现并发注册逻辑
  - 手动运行完成首批账号注册

### Phase 3：后端 API（预计 2 天）

- [ ] **3.1 视频任务 API**
  - 在 `backend/main.py` 添加 `POST /api/video-tasks`
  - 在 `backend/main.py` 添加 `GET /api/video-tasks/{taskId}`
  - 实现任务记录存储（`video_tasks/` 目录）

- [ ] **3.2 后台任务执行**
  - 参考 `run_image_task()` 实现 `run_video_task()`
  - 集成调度器 `VideoGenerationScheduler`
  - 实现视频下载保存到 `videos/` 目录

- [ ] **3.3 配置管理**
  - 创建 `backend/automation/config.py` 读取配置
  - 环境变量或 `.env` 管理敏感信息（IMAP 密码等）

### Phase 4：前端集成（预计 2 天）

- [ ] **4.1 镜头卡片改造**
  - 在 `ShotCard.tsx` 添加"生视频"按钮
  - 调用 `POST /api/video-tasks` 提交任务
  - 显示任务状态（生成中/完成/失败）

- [ ] **4.2 视频素材流**
  - 在 `Step3_DeconstructionReview.tsx` 添加视频列表
  - 从 `generated_xxx/videos/` 加载视频
  - 实现视频预览播放

- [ ] **4.3 配置弹窗**
  - 修改供应商按钮为"生图供应商"
  - 新增"生视频配置"弹窗（headless/任务数/超时）

### Phase 5：测试与优化（预计 1 天）

- [ ] **5.1 端到端测试**
  - 单镜头生视频完整流程
  - 多镜头并行生成
  - 账号切换逻辑

- [ ] **5.2 错误处理**
  - 登录失效检测与提示
  - 任务超时处理
  - 失败重试机制

---

## 目标场景
- 在人工改写界面（镜头卡片）的视频描述右侧新增"生视频"按钮。
- 点击后自动驱动 Chrome（可后台/可见，可配置）访问视频生成平台，完成图生视频任务。
- **主要方案**：Lovart.ai + 批量账号系统
- **备选方案**：海螺 AI（暂不实现，见文档末尾附录）

---

# 方案一：Lovart.ai + 批量账号系统（主要方案）

## 平台说明
- **目标网址**：`https://www.lovart.ai/canvas?projectId={id}&agent=1`
- **限制**：每个账号每天仅能生成 3 个视频
- **注册方式**：邮箱 + 验证码
- **应对策略**：批量注册账号，通过账号池轮换满足每日生产需求

## 批量账号系统架构

┌─────────────────────┐     ┌─────────────────────┐     ┌─────────────────────┐
│   邮箱系统           │     │   指纹浏览器         │     │   自动化引擎         │
│  (Catch-All+IMAP)   │────▶│  (Playwright注入)   │◀────│  (账号池调度)        │
└─────────────────────┘     └─────────────────────┘     └─────────────────────┘
         │                           │                           │
         ▼                           ▼                           ▼
   API获取验证码              每账号独立指纹               批量注册/生成调度

### 1. 邮箱系统：自建域名 + Cloudflare Catch-All + IMAP

#### 1.1 域名与邮件路由配置
1. **购买域名**（如 `yourvideobot.com`，约 $10/年）
2. **Cloudflare Email Routing 配置**：
   - 添加域名到 Cloudflare
   - 启用 Email Routing → 配置 Catch-All 规则
   - 所有 `*@yourvideobot.com` 邮件转发到一个主邮箱（如 Gmail）
3. **结果**：`user001@yourvideobot.com`、`user002@yourvideobot.com` 等无限邮箱地址

#### 1.2 IMAP 收件脚本
```python
# automation/email_receiver.py
import imaplib
import email
import re
import time

class EmailReceiver:
    def __init__(self, imap_server: str, username: str, password: str):
        self.imap_server = imap_server
        self.username = username
        self.password = password
    
    def connect(self):
        self.mail = imaplib.IMAP4_SSL(self.imap_server)
        self.mail.login(self.username, self.password)
        self.mail.select("inbox")
    
    def get_verification_code(self, target_email: str, timeout: int = 120) -> str | None:
        """获取发送到指定邮箱地址的验证码"""
        start_time = time.time()
        while time.time() - start_time < timeout:
            self.mail.recent()
            status, messages = self.mail.search(None, f'(TO "{target_email}")')
            if status != "OK":
                time.sleep(5)
                continue
            
            msg_ids = messages[0].split()
            if not msg_ids:
                time.sleep(5)
                continue
            
            latest_id = msg_ids[-1]
            status, msg_data = self.mail.fetch(latest_id, "(RFC822)")
            if status != "OK":
                continue
            
            raw_email = msg_data[0][1]
            msg = email.message_from_bytes(raw_email)
            body = self._get_body(msg)
            
            # 匹配验证码（4-6位数字）
            code_match = re.search(r'\b(\d{4,6})\b', body)
            if code_match:
                return code_match.group(1)
            
            time.sleep(5)
        return None
    
    def _get_body(self, msg) -> str:
        if msg.is_multipart():
            for part in msg.walk():
                if part.get_content_type() == "text/plain":
                    return part.get_payload(decode=True).decode('utf-8', errors='ignore')
        return msg.get_payload(decode=True).decode('utf-8', errors='ignore')
    
    def close(self):
        self.mail.logout()
```

### 2. 指纹浏览器：Playwright + 自建指纹注入

#### 2.1 指纹生成与注入
```python
# automation/fingerprint_browser.py
import random
import hashlib
from pathlib import Path
from playwright.sync_api import sync_playwright

def generate_fingerprint(seed: str) -> dict:
    """根据账号 ID 生成一致的指纹配置"""
    random.seed(hashlib.md5(seed.encode()).hexdigest())
    return {
        "userAgent": random.choice([
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
        ]),
        "platform": random.choice(["Win32", "MacIntel"]),
        "language": random.choice(["en-US", "zh-CN"]),
        "timezone": random.choice(["America/New_York", "Asia/Shanghai"]),
        "screen": {"width": random.choice([1920, 1680, 1440]), "height": random.choice([1080, 1050, 900])},
        "hardwareConcurrency": random.choice([4, 8, 12]),
        "deviceMemory": random.choice([4, 8, 16]),
        "webgl": {
            "vendor": random.choice(["Google Inc. (NVIDIA)", "Google Inc. (Intel)"]),
            "renderer": random.choice(["ANGLE (NVIDIA GeForce GTX 1080)", "ANGLE (Intel UHD Graphics 630)"]),
        },
        "canvasNoise": random.random() * 0.0001,
    }

INJECT_SCRIPT = """
(fp) => {
    Object.defineProperty(navigator, 'userAgent', { get: () => fp.userAgent });
    Object.defineProperty(navigator, 'platform', { get: () => fp.platform });
    Object.defineProperty(navigator, 'language', { get: () => fp.language });
    Object.defineProperty(navigator, 'hardwareConcurrency', { get: () => fp.hardwareConcurrency });
    Object.defineProperty(navigator, 'deviceMemory', { get: () => fp.deviceMemory });
    Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
    Object.defineProperty(screen, 'width', { get: () => fp.screen.width });
    Object.defineProperty(screen, 'height', { get: () => fp.screen.height });
    // WebGL
    const proxy = { apply: (t, a, args) => args[0]===37445?fp.webgl.vendor:args[0]===37446?fp.webgl.renderer:Reflect.apply(t,a,args) };
    WebGLRenderingContext.prototype.getParameter = new Proxy(WebGLRenderingContext.prototype.getParameter, proxy);
}
"""

class FingerprintBrowser:
    def __init__(self, account_id: str, profiles_dir: str = "./browser_profiles"):
        self.account_id = account_id
        self.profile_dir = Path(profiles_dir) / account_id
        self.profile_dir.mkdir(parents=True, exist_ok=True)
        self.fingerprint = generate_fingerprint(account_id)
    
    def launch(self, headless: bool = False):
        self.playwright = sync_playwright().start()
        self.context = self.playwright.chromium.launch_persistent_context(
            user_data_dir=str(self.profile_dir),
            headless=headless,
            args=['--disable-blink-features=AutomationControlled'],
            user_agent=self.fingerprint["userAgent"],
            viewport={"width": self.fingerprint["screen"]["width"], "height": self.fingerprint["screen"]["height"]},
            locale=self.fingerprint["language"],
            timezone_id=self.fingerprint["timezone"],
        )
        self.context.add_init_script(INJECT_SCRIPT, self.fingerprint)
        page = self.context.pages[0] if self.context.pages else self.context.new_page()
        return self.context, page
    
    def close(self):
        self.context.close()
        self.playwright.stop()
```

### 3. 账号池管理
```python
# automation/account_pool.py
import json
from datetime import date
from pathlib import Path
from dataclasses import dataclass, asdict

@dataclass
class Account:
    id: str
    email: str
    password: str
    registered: bool = False
    daily_usage: int = 0
    last_used_date: str = ""
    status: str = "active"

class AccountPool:
    DAILY_LIMIT = 3
    
    def __init__(self, pool_file: str = "./account_pool.json"):
        self.pool_file = Path(pool_file)
        self.accounts: dict[str, Account] = {}
        self._load()
    
    def _load(self):
        if self.pool_file.exists():
            data = json.loads(self.pool_file.read_text())
            self.accounts = {k: Account(**v) for k, v in data.items()}
    
    def _save(self):
        self.pool_file.write_text(json.dumps({k: asdict(v) for k, v in self.accounts.items()}, indent=2))
    
    def get_available_account(self):
        today = date.today().isoformat()
        for acc in self.accounts.values():
            if acc.status != "active" or not acc.registered:
                continue
            if acc.last_used_date != today:
                acc.daily_usage = 0
                acc.last_used_date = today
            if acc.daily_usage < self.DAILY_LIMIT:
                return acc
        return None
    
    def mark_used(self, account_id: str):
        acc = self.accounts.get(account_id)
        if acc:
            acc.daily_usage += 1
            acc.last_used_date = date.today().isoformat()
            self._save()
    
    def get_stats(self):
        today = date.today().isoformat()
        remaining = sum(
            max(0, self.DAILY_LIMIT - a.daily_usage) if a.last_used_date == today else self.DAILY_LIMIT
            for a in self.accounts.values() if a.registered and a.status == "active"
        )
        return {"total": len(self.accounts), "remaining_quota": remaining}
```

### 4. Lovart.ai 自动化流程（核心）

#### 4.1 关键选择器

| 功能 | 选择器 | 说明 |
|------|--------|------|
| 注册按钮 | `button:has(span.mantine-Button-label:text("注册"))` | 首页注册入口 |
| 邮箱输入框 | `input[type="email"]` | 邮箱输入 |
| Success 标识 | `#success-text` | 邮箱验证成功标识 |
| 继续按钮 | `button:has(span.mantine-Button-label:text("使用邮箱继续"))` | 点击继续登录 |
| 验证码输入框 | `input[data-testid="undefined-input-0"]` ~ `input[data-testid="undefined-input-5"]` | 6位验证码 |
| 视频描述输入框 | `div[data-testid="agent-message-input"]` | contenteditable |
| 附件上传按钮 | `button.rounded-full:has(svg path[d^="M16 1.1"])` | 回形针图标，上传图片 |
| 下载按钮 | `button:has(svg path[d*="M7.858 2.023"])` | 视频播放器上的下载 |

#### 4.2 自动化代码

```python
# automation/lovart_automation.py
import asyncio
import json
from pathlib import Path
from datetime import datetime
from playwright.async_api import async_playwright, Page, BrowserContext

class LovartAutomation:
    """Lovart.ai 自动化核心类（异步实现，支持双层并行）"""
    
    BASE_URL = "https://www.lovart.ai/zh"
    HOME_URL = "https://www.lovart.ai/zh/home"
    PROMPT_PREFIX = ""
    
    def __init__(self, email_receiver, account_pool, config: dict = None):
        self.email_receiver = email_receiver
        self.account_pool = account_pool
        self.config = config or {}
        self.PROMPT_PREFIX = self.config.get("prompt_prefix", "")
    
    async def login_or_register(self, account, page: Page) -> bool:
        """注册或登录流程（异步）"""
        try:
            await page.goto(self.BASE_URL)
            await page.wait_for_load_state("networkidle")
            await page.click('button:has(span.mantine-Button-label:text("注册"))')
            await page.wait_for_timeout(1000)
            
            await page.fill('input[type="email"]', account.email)
            await page.wait_for_timeout(500)
            
            await page.wait_for_selector('#success-text', timeout=30000)
            await page.click('button:has(span.mantine-Button-label:text("使用邮箱继续"))')
            await page.wait_for_timeout(2000)
            
            # 异步获取验证码
            code = await asyncio.to_thread(
                self.email_receiver.get_verification_code, account.email, 120
            )
            if not code or len(code) != 6:
                print(f"[{account.id}] 验证码获取失败: {code}")
                return False
            
            for i, digit in enumerate(code):
                await page.fill(f'input[data-testid="undefined-input-{i}"]', digit)
                await page.wait_for_timeout(100)
            
            await page.wait_for_timeout(3000)
            
            if "/home" in page.url or await page.query_selector('div[data-testid="agent-message-input"]'):
                print(f"[{account.id}] 登录成功")
                return True
            return False
            
        except Exception as e:
            print(f"[{account.id}] 登录失败: {e}")
            return False
    
    async def generate_video_single(self, page: Page, image_path: str, prompt: str, task_id: str) -> str | None:
        """单次视频生成（异步）"""
        try:
            await page.goto(self.HOME_URL)
            await page.wait_for_load_state("networkidle")
            await page.wait_for_timeout(2000)
            
            timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
            full_prompt = f"{self.PROMPT_PREFIX}{task_id}_{timestamp} {prompt}"
            
            input_div = page.locator('div[data-testid="agent-message-input"]')
            await input_div.click()
            await page.keyboard.type(full_prompt)
            await page.wait_for_timeout(500)
            
            async with page.expect_file_chooser() as fc_info:
                await page.click('button.rounded-full:has(svg path[d^="M16 1.1"])')
            file_chooser = await fc_info.value
            await file_chooser.set_files(image_path)
            await page.wait_for_timeout(2000)
            
            await page.keyboard.press("Enter")
            
            download_btn = 'button:has(svg path[d*="M7.858 2.023"])'
            await page.wait_for_selector(download_btn, timeout=600000)
            
            async with page.expect_download() as download_info:
                await page.click(download_btn)
            download = await download_info.value
            
            video_filename = f"{task_id}_{timestamp}.mp4"
            download_path = Path(self.config.get("output_dir", ".")) / video_filename
            await download.save_as(str(download_path))
            
            print(f"[{task_id}] 视频生成成功: {download_path}")
            return str(download_path)
            
        except Exception as e:
            print(f"[{task_id}] 视频生成失败: {e}")
            return None
    
    async def generate_videos_for_shot(
        self, ctx: BrowserContext, image_path: str, prompt: str, shot_id: str, count: int = 3
    ) -> list[str]:
        """
        为单个镜头并行生成多个视频
        - 在同一个浏览器上下文中开启多个 Tab 并行执行
        """
        pages = [await ctx.new_page() for _ in range(count)]
        
        # 并行执行所有生成任务
        tasks = [
            self.generate_video_single(page, image_path, prompt, f"{shot_id}_v{i+1}")
            for i, page in enumerate(pages)
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # 关闭页面
        for page in pages:
            await page.close()
        
        # 过滤成功结果
        return [r for r in results if isinstance(r, str)]


class AsyncFingerprintBrowser:
    """异步指纹浏览器管理器"""
    
    def __init__(self, account_id: str, fingerprint: dict = None):
        self.account_id = account_id
        self.fingerprint = fingerprint or self._generate_fingerprint()
        self.playwright = None
        self.browser = None
    
    def _generate_fingerprint(self) -> dict:
        import hashlib
        seed = hashlib.md5(self.account_id.encode()).hexdigest()
        return {
            "userAgent": f"Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.{int(seed[:4], 16) % 1000}.0",
            "viewport": {"width": 1920, "height": 1080},
            "locale": "zh-CN",
            "timezone_id": "Asia/Shanghai",
        }
    
    async def launch(self, headless: bool = False) -> BrowserContext:
        self.playwright = await async_playwright().start()
        self.browser = await self.playwright.chromium.launch(headless=headless)
        ctx = await self.browser.new_context(
            user_agent=self.fingerprint["userAgent"],
            viewport=self.fingerprint["viewport"],
            locale=self.fingerprint["locale"],
            timezone_id=self.fingerprint["timezone_id"],
        )
        return ctx
    
    async def close(self):
        if self.browser:
            await self.browser.close()
        if self.playwright:
            await self.playwright.stop()


class VideoGenerationScheduler:
    """
    视频生成调度器（支持双层并行）
    - 任务级并行：多个镜头同时处理（每个镜头分配一个账号）
    - 视频级并行：每个镜头同时生成 3 个视频
    """
    
    def __init__(self, config: dict):
        self.config = config
        self.account_pool = AccountPool(config.get("pool_file", "./account_pool.json"))
        self.email_receiver = EmailReceiver(
            imap_server=config["imap_server"],
            username=config["imap_username"],
            password=config["imap_password"],
        )
    
    async def process_single_shot(self, shot_data: dict) -> dict:
        """
        处理单个镜头（异步）
        shot_data: { shot_id, image_path, prompt, count }
        返回: { shot_id, videos: [...], error: None }
        """
        shot_id = shot_data["shot_id"]
        
        # 获取可用账号
        account = self.account_pool.get_available_account()
        if not account:
            return {"shot_id": shot_id, "videos": [], "error": "无可用账号"}
        
        automation = LovartAutomation(self.email_receiver, self.account_pool, self.config)
        browser = AsyncFingerprintBrowser(account.id)
        
        try:
            ctx = await browser.launch(headless=self.config.get("headless", False))
            
            # 先登录（使用第一个页面）
            login_page = await ctx.new_page()
            if not await automation.login_or_register(account, login_page):
                return {"shot_id": shot_id, "videos": [], "error": "登录失败"}
            await login_page.close()
            
            # 并行生成视频
            videos = await automation.generate_videos_for_shot(
                ctx=ctx,
                image_path=shot_data["image_path"],
                prompt=shot_data["prompt"],
                shot_id=shot_id,
                count=shot_data.get("count", 3)
            )
            
            # 标记账号使用
            self.account_pool.mark_used(account.id)
            
            return {"shot_id": shot_id, "videos": videos, "error": None}
            
        except Exception as e:
            return {"shot_id": shot_id, "videos": [], "error": str(e)}
        finally:
            await browser.close()
    
    async def process_multiple_shots(self, shots: list[dict], max_concurrent: int = 3) -> list[dict]:
        """
        并行处理多个镜头
        - shots: [{ shot_id, image_path, prompt, count }, ...]
        - max_concurrent: 最大并发镜头数（受限于可用账号数）
        """
        self.email_receiver.connect()
        
        try:
            # 使用 Semaphore 控制并发数
            semaphore = asyncio.Semaphore(max_concurrent)
            
            async def limited_task(shot_data):
                async with semaphore:
                    return await self.process_single_shot(shot_data)
            
            # 并行执行所有任务
            tasks = [limited_task(shot) for shot in shots]
            results = await asyncio.gather(*tasks)
            
            return results
            
        finally:
            self.email_receiver.close()
    
    def run(self, shots: list[dict], max_concurrent: int = 3) -> list[dict]:
        """同步入口，供外部调用"""
        return asyncio.run(self.process_multiple_shots(shots, max_concurrent))


# ========== 使用示例 ==========
if __name__ == "__main__":
    config = {
        "imap_server": "imap.gmail.com",
        "imap_username": "your-inbox@gmail.com",
        "imap_password": "your-app-password",
        "pool_file": "./account_pool.json",
        "output_dir": "./videos/",
        "prompt_prefix": "",
        "headless": False,
    }
    
    # 多个镜头任务
    shots = [
        {"shot_id": "shot_01", "image_path": "/path/to/img1.png", "prompt": "描述1", "count": 3},
        {"shot_id": "shot_02", "image_path": "/path/to/img2.png", "prompt": "描述2", "count": 3},
        {"shot_id": "shot_03", "image_path": "/path/to/img3.png", "prompt": "描述3", "count": 3},
    ]
    
    scheduler = VideoGenerationScheduler(config)
    
    # 并行处理：最多 3 个镜头同时处理，每个镜头同时生成 3 个视频
    results = scheduler.run(shots, max_concurrent=3)
    
    for r in results:
        print(f"镜头 {r['shot_id']}: {len(r['videos'])} 个视频, 错误: {r['error']}")
```

#### 4.3 配置文件示例

```json
{
  "imap_server": "imap.gmail.com",
  "imap_username": "your-inbox@gmail.com",
  "imap_password": "your-app-password",
  "pool_file": "./account_pool.json",
  "output_dir": "./workspaces/{id}/generated_xxx/videos/",
  "prompt_prefix": "",
  "headless": false
}
```

> **说明**：`prompt_prefix` 为视频描述前缀，可配置为任意文字，留空则不添加前缀。

### 5. 批量账号预注册工具

```python
# automation/batch_register.py
import asyncio
from lovart_automation import LovartAutomation, AsyncFingerprintBrowser
from account_pool import AccountPool, Account
from email_receiver import EmailReceiver

async def register_single_account(account: Account, automation: LovartAutomation, headless: bool = False) -> bool:
    """注册单个账号"""
    browser = AsyncFingerprintBrowser(account.id)
    try:
        ctx = await browser.launch(headless=headless)
        page = await ctx.new_page()
        success = await automation.login_or_register(account, page)
        if success:
            account.registered = True
            print(f"✓ 账号 {account.email} 注册成功")
        else:
            print(f"✗ 账号 {account.email} 注册失败")
        return success
    except Exception as e:
        print(f"✗ 账号 {account.email} 注册异常: {e}")
        return False
    finally:
        await browser.close()

async def batch_register(config: dict, max_concurrent: int = 3):
    """批量预注册账号"""
    pool = AccountPool(config["pool_file"])
    email_receiver = EmailReceiver(
        imap_server=config["imap_server"],
        username=config["imap_username"],
        password=config["imap_password"],
    )
    email_receiver.connect()
    automation = LovartAutomation(email_receiver, pool, config)
    
    unregistered = [acc for acc in pool.accounts.values() if not acc.registered]
    print(f"待注册账号数: {len(unregistered)}")
    
    semaphore = asyncio.Semaphore(max_concurrent)
    async def limited_register(account):
        async with semaphore:
            return await register_single_account(account, automation, config.get("headless", False))
    
    tasks = [limited_register(acc) for acc in unregistered]
    results = await asyncio.gather(*tasks)
    pool._save()
    email_receiver.close()
    
    success_count = sum(1 for r in results if r)
    print(f"\n注册完成: {success_count}/{len(unregistered)} 成功")

def generate_accounts(domain: str, count: int, pool_file: str = "./account_pool.json"):
    """生成账号配置文件"""
    import json
    from pathlib import Path
    
    accounts = {}
    for i in range(1, count + 1):
        account_id = f"user{i:03d}"
        accounts[account_id] = {
            "id": account_id,
            "email": f"{account_id}@{domain}",
            "password": "",
            "registered": False,
            "daily_usage": 0,
            "last_used_date": "",
            "status": "active"
        }
    Path(pool_file).write_text(json.dumps(accounts, indent=2, ensure_ascii=False))
    print(f"已生成 {count} 个账号配置到 {pool_file}")

# 使用: python batch_register.py generate yourvideobot.com 100
# 或:   python batch_register.py （执行批量注册）
```

---

## 与现有图片生成逻辑的对照参考

> 视频生成需参考现有图片生成模式，保持架构一致性。

### 参考项对照表

| 模块 | 图片生成（现有） | 视频生成（新增） |
|------|------------------|------------------|
| **后端 API** | `POST /api/image-tasks` | `POST /api/video-tasks` |
| **任务状态查询** | `GET /api/image-tasks/{taskId}` | `GET /api/video-tasks/{taskId}` |
| **任务记录目录** | `generated_xxx/image_tasks/` | `generated_xxx/video_tasks/` |
| **产物目录** | `generated_xxx/shots/` | `generated_xxx/videos/` |
| **选中记录** | `selected_images.json` | 全保留，无需选择 |
| **前端组件** | `Step3_DeconstructionReview.tsx` | 同文件，新增视频素材流 |
| **并发生成** | `asyncio.gather()` 并发 N 张图 | `asyncio.gather()` 并发 3 个视频 |

### 关键参考文件

```
backend/main.py
├── POST /api/image-tasks          → 参考创建视频任务
├── GET /api/image-tasks/{taskId}  → 参考任务状态查询
├── run_image_task()               → 参考后台任务执行

frontend/components/workflow/Step3_DeconstructionReview.tsx
├── pollTaskStatus()               → 参考任务轮询
├── generatedDir                   → 参考目录结构

workspaces/{id}/generated_xxx/
├── selected_images.json           → 结构: { "indexes": { "shot_id": "filename" } }
├── image_tasks/                   → 任务记录 JSON
```

---

## 数据输入与存储

### 输入数据
- **首帧图**：从 `selected_images.json` 读取，每镜头**仅 1 张**选中图
- **视频描述**：镜头的 `videoDescription` 字段
- **完整提示词**：`{prompt_prefix}{shot_id}_{timestamp} {videoDescription}`

### 输出存储

- **视频文件**：`workspaces/{id}/generated_xxx/videos/{shot_id}_{timestamp}_v{1,2,3}.mp4`
- **任务记录**：`workspaces/{id}/generated_xxx/video_tasks/{taskId}.json`
- **全保留**，无需选择逻辑

---

## 前端改动

### 镜头卡片

- 视频描述右侧增加 **"生视频"** 按钮
- 点击后调用 `POST /api/video-tasks`

### 配置弹窗

- 现有"供应商"改为"生图供应商"
- 新增 **"生视频配置"** 按钮，可配置：headless/可见、任务数、超时

### 视频素材流

- 展示逻辑参考图片素材流
- **全保留**，不需要选择
- 从 `generated_xxx/videos/` 加载视频并渲染

---

## 后端 API

### `POST /api/video-tasks`

创建视频生成任务（参考 `/api/image-tasks`）。

### `GET /api/video-tasks/{taskId}`

查询任务状态（参考 `/api/image-tasks/{taskId}`）。

---

## 配置参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `headless` | `false` | 浏览器模式 |
| `prompt_prefix` | `""` | 视频描述前缀（可配置） |
| `task_timeout` | `600s` | 单任务超时 |
| `max_concurrent_tasks` | `3` | 最大并发任务数 |

---

## 安全与凭证

- 账号池、IMAP 凭证**不入仓库**
- 浏览器 Profile 本地存储，复用登录态

---

## 监控与错误处理

- 前端显示任务状态和错误摘要
- 后端记录错误日志和截图
- 失败任务支持重试

---

# 附录：方案二 - 海螺 AI（暂不实现）

> ⚠️ **状态：暂不实现**  
> 以下内容保留作为备选方案参考，当前优先使用 Lovart.ai 方案。

## 平台说明

- **目标网址**：`https://hailuoai.com/create/image-to-video`
- **我的作品**：`https://hailuoai.com/mine`

## 自动化步骤

1. **启动浏览器**
   - 可选：headless/有头、代理/VPN、复用用户数据目录（保登录态）。

2. **打开页面** `https://hailuoai.com/create/image-to-video`

3. **上传图片**
   - 定位"拖拽/粘贴/点击上传新图片"区域（含 SVG 与文字），上传 `selected_images.json` 中的图片文件。

4. **填写视频描述**
   - 定位 `#video-create-textarea`（contenteditable）写入视频描述。
   - 前缀格式：`{镜头序号}_{YYYYMMDDHHmmss}`，示例 `01_20251201110836`

5. **设置生成数量 = 3**
   - 操作 `ant-input-number` 控件：可直接设值为 3，或点击上箭头两次。

6. **点击生成**
   - 点击与数量控件联动的生成按钮（精确选择器需实测确认）。

7. **结果监控与下载**
   - 进入 `https://hailuoai.com/mine`，轮询生成列表。
   - 定位含有前缀 `{镜头序号}_{时间戳}` 的 `<span class="prompt-plain-span">` 文本，确认生成完成。
   - 匹配到后，触发下载（点击下载/导出按钮；下载按钮选择器需实测）。
   - 保存视频至 `workspaces/{id}/generated_xxx/videos/`，文件名保留前缀。

## 关键选择器（待实测）

| 元素 | 选择器 |
|------|--------|
| 视频描述输入框 | `#video-create-textarea` |
| 生成数量控件 | `.ant-input-number` |
| 生成按钮 | 待实测 |
| 作品列表项标题 | `span.prompt-plain-span` |
| 下载按钮 | 待实测 |
