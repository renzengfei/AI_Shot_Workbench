# 网页自动化生视频迭代文档

## 目标场景
- 在人工改写界面（镜头卡片）的视频描述右侧新增"生视频"按钮。
- 点击后自动驱动 Chrome（可后台/可见，可配置）访问视频生成平台，完成图生视频任务。
- **主要方案**：Lovart.ai + 批量账号系统
- **备选方案**：海螺 AI（暂不实现，见文档末尾附录）

---

# 方案一：Lovart.ai + 批量账号系统（主要方案）

## 平台说明
- **目标网址**：`https://www.lovart.ai/canvas?projectId={id}&agent=1`
- **限制**：每个账号每天仅能生成 3 个视频
- **注册方式**：邮箱 + 验证码
- **应对策略**：批量注册账号，通过账号池轮换满足每日生产需求

## 批量账号系统架构

┌─────────────────────┐     ┌─────────────────────┐     ┌─────────────────────┐
│   邮箱系统           │     │   指纹浏览器         │     │   自动化引擎         │
│  (Catch-All+IMAP)   │────▶│  (Playwright注入)   │◀────│  (账号池调度)        │
└─────────────────────┘     └─────────────────────┘     └─────────────────────┘
         │                           │                           │
         ▼                           ▼                           ▼
   API获取验证码              每账号独立指纹               批量注册/生成调度

### 1. 邮箱系统：自建域名 + Cloudflare Catch-All + IMAP

#### 1.1 域名与邮件路由配置
1. **购买域名**（如 `yourvideobot.com`，约 $10/年）
2. **Cloudflare Email Routing 配置**：
   - 添加域名到 Cloudflare
   - 启用 Email Routing → 配置 Catch-All 规则
   - 所有 `*@yourvideobot.com` 邮件转发到一个主邮箱（如 Gmail）
3. **结果**：`user001@yourvideobot.com`、`user002@yourvideobot.com` 等无限邮箱地址

#### 1.2 IMAP 收件脚本
```python
# automation/email_receiver.py
import imaplib
import email
import re
import time

class EmailReceiver:
    def __init__(self, imap_server: str, username: str, password: str):
        self.imap_server = imap_server
        self.username = username
        self.password = password
    
    def connect(self):
        self.mail = imaplib.IMAP4_SSL(self.imap_server)
        self.mail.login(self.username, self.password)
        self.mail.select("inbox")
    
    def get_verification_code(self, target_email: str, timeout: int = 120) -> str | None:
        """获取发送到指定邮箱地址的验证码"""
        start_time = time.time()
        while time.time() - start_time < timeout:
            self.mail.recent()
            status, messages = self.mail.search(None, f'(TO "{target_email}")')
            if status != "OK":
                time.sleep(5)
                continue
            
            msg_ids = messages[0].split()
            if not msg_ids:
                time.sleep(5)
                continue
            
            latest_id = msg_ids[-1]
            status, msg_data = self.mail.fetch(latest_id, "(RFC822)")
            if status != "OK":
                continue
            
            raw_email = msg_data[0][1]
            msg = email.message_from_bytes(raw_email)
            body = self._get_body(msg)
            
            # 匹配验证码（4-6位数字）
            code_match = re.search(r'\b(\d{4,6})\b', body)
            if code_match:
                return code_match.group(1)
            
            time.sleep(5)
        return None
    
    def _get_body(self, msg) -> str:
        if msg.is_multipart():
            for part in msg.walk():
                if part.get_content_type() == "text/plain":
                    return part.get_payload(decode=True).decode('utf-8', errors='ignore')
        return msg.get_payload(decode=True).decode('utf-8', errors='ignore')
    
    def close(self):
        self.mail.logout()
```

### 2. 指纹浏览器：Playwright + 自建指纹注入

#### 2.1 指纹生成与注入
```python
# automation/fingerprint_browser.py
import random
import hashlib
from pathlib import Path
from playwright.sync_api import sync_playwright

def generate_fingerprint(seed: str) -> dict:
    """根据账号 ID 生成一致的指纹配置"""
    random.seed(hashlib.md5(seed.encode()).hexdigest())
    return {
        "userAgent": random.choice([
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
        ]),
        "platform": random.choice(["Win32", "MacIntel"]),
        "language": random.choice(["en-US", "zh-CN"]),
        "timezone": random.choice(["America/New_York", "Asia/Shanghai"]),
        "screen": {"width": random.choice([1920, 1680, 1440]), "height": random.choice([1080, 1050, 900])},
        "hardwareConcurrency": random.choice([4, 8, 12]),
        "deviceMemory": random.choice([4, 8, 16]),
        "webgl": {
            "vendor": random.choice(["Google Inc. (NVIDIA)", "Google Inc. (Intel)"]),
            "renderer": random.choice(["ANGLE (NVIDIA GeForce GTX 1080)", "ANGLE (Intel UHD Graphics 630)"]),
        },
        "canvasNoise": random.random() * 0.0001,
    }

INJECT_SCRIPT = """
(fp) => {
    Object.defineProperty(navigator, 'userAgent', { get: () => fp.userAgent });
    Object.defineProperty(navigator, 'platform', { get: () => fp.platform });
    Object.defineProperty(navigator, 'language', { get: () => fp.language });
    Object.defineProperty(navigator, 'hardwareConcurrency', { get: () => fp.hardwareConcurrency });
    Object.defineProperty(navigator, 'deviceMemory', { get: () => fp.deviceMemory });
    Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
    Object.defineProperty(screen, 'width', { get: () => fp.screen.width });
    Object.defineProperty(screen, 'height', { get: () => fp.screen.height });
    // WebGL
    const proxy = { apply: (t, a, args) => args[0]===37445?fp.webgl.vendor:args[0]===37446?fp.webgl.renderer:Reflect.apply(t,a,args) };
    WebGLRenderingContext.prototype.getParameter = new Proxy(WebGLRenderingContext.prototype.getParameter, proxy);
}
"""

class FingerprintBrowser:
    def __init__(self, account_id: str, profiles_dir: str = "./browser_profiles"):
        self.account_id = account_id
        self.profile_dir = Path(profiles_dir) / account_id
        self.profile_dir.mkdir(parents=True, exist_ok=True)
        self.fingerprint = generate_fingerprint(account_id)
    
    def launch(self, headless: bool = False):
        self.playwright = sync_playwright().start()
        self.context = self.playwright.chromium.launch_persistent_context(
            user_data_dir=str(self.profile_dir),
            headless=headless,
            args=['--disable-blink-features=AutomationControlled'],
            user_agent=self.fingerprint["userAgent"],
            viewport={"width": self.fingerprint["screen"]["width"], "height": self.fingerprint["screen"]["height"]},
            locale=self.fingerprint["language"],
            timezone_id=self.fingerprint["timezone"],
        )
        self.context.add_init_script(INJECT_SCRIPT, self.fingerprint)
        page = self.context.pages[0] if self.context.pages else self.context.new_page()
        return self.context, page
    
    def close(self):
        self.context.close()
        self.playwright.stop()
```

### 3. 账号池管理
```python
# automation/account_pool.py
import json
from datetime import date
from pathlib import Path
from dataclasses import dataclass, asdict

@dataclass
class Account:
    id: str
    email: str
    password: str
    registered: bool = False
    daily_usage: int = 0
    last_used_date: str = ""
    status: str = "active"

class AccountPool:
    DAILY_LIMIT = 3
    
    def __init__(self, pool_file: str = "./account_pool.json"):
        self.pool_file = Path(pool_file)
        self.accounts: dict[str, Account] = {}
        self._load()
    
    def _load(self):
        if self.pool_file.exists():
            data = json.loads(self.pool_file.read_text())
            self.accounts = {k: Account(**v) for k, v in data.items()}
    
    def _save(self):
        self.pool_file.write_text(json.dumps({k: asdict(v) for k, v in self.accounts.items()}, indent=2))
    
    def get_available_account(self):
        today = date.today().isoformat()
        for acc in self.accounts.values():
            if acc.status != "active" or not acc.registered:
                continue
            if acc.last_used_date != today:
                acc.daily_usage = 0
                acc.last_used_date = today
            if acc.daily_usage < self.DAILY_LIMIT:
                return acc
        return None
    
    def mark_used(self, account_id: str):
        acc = self.accounts.get(account_id)
        if acc:
            acc.daily_usage += 1
            acc.last_used_date = date.today().isoformat()
            self._save()
    
    def get_stats(self):
        today = date.today().isoformat()
        remaining = sum(
            max(0, self.DAILY_LIMIT - a.daily_usage) if a.last_used_date == today else self.DAILY_LIMIT
            for a in self.accounts.values() if a.registered and a.status == "active"
        )
        return {"total": len(self.accounts), "remaining_quota": remaining}
```

### 4. Lovart.ai 自动化流程（核心）

#### 4.1 关键选择器

| 功能 | 选择器 | 说明 |
|------|--------|------|
| 注册按钮 | `button:has(span.mantine-Button-label:text("注册"))` | 首页注册入口 |
| 邮箱输入框 | `input[type="email"]` | 邮箱输入 |
| Success 标识 | `#success-text` | 邮箱验证成功标识 |
| 继续按钮 | `button:has(span.mantine-Button-label:text("使用邮箱继续"))` | 点击继续登录 |
| 验证码输入框 | `input[data-testid="undefined-input-0"]` ~ `input[data-testid="undefined-input-5"]` | 6位验证码 |
| 视频描述输入框 | `div[data-testid="agent-message-input"]` | contenteditable |
| 附件上传按钮 | `button.rounded-full:has(svg path[d^="M16 1.1"])` | 回形针图标，上传图片 |
| 下载按钮 | `button:has(svg path[d*="M7.858 2.023"])` | 视频播放器上的下载 |

#### 4.2 自动化代码

```python
# automation/lovart_automation.py
import asyncio
import json
from pathlib import Path
from datetime import datetime
from playwright.async_api import async_playwright, Page, BrowserContext

class LovartAutomation:
    """Lovart.ai 自动化核心类（异步实现，支持双层并行）"""
    
    BASE_URL = "https://www.lovart.ai/zh"
    HOME_URL = "https://www.lovart.ai/zh/home"
    PROMPT_PREFIX = ""
    
    def __init__(self, email_receiver, account_pool, config: dict = None):
        self.email_receiver = email_receiver
        self.account_pool = account_pool
        self.config = config or {}
        self.PROMPT_PREFIX = self.config.get("prompt_prefix", "")
    
    async def login_or_register(self, account, page: Page) -> bool:
        """注册或登录流程（异步）"""
        try:
            await page.goto(self.BASE_URL)
            await page.wait_for_load_state("networkidle")
            await page.click('button:has(span.mantine-Button-label:text("注册"))')
            await page.wait_for_timeout(1000)
            
            await page.fill('input[type="email"]', account.email)
            await page.wait_for_timeout(500)
            
            await page.wait_for_selector('#success-text', timeout=30000)
            await page.click('button:has(span.mantine-Button-label:text("使用邮箱继续"))')
            await page.wait_for_timeout(2000)
            
            # 异步获取验证码
            code = await asyncio.to_thread(
                self.email_receiver.get_verification_code, account.email, 120
            )
            if not code or len(code) != 6:
                print(f"[{account.id}] 验证码获取失败: {code}")
                return False
            
            for i, digit in enumerate(code):
                await page.fill(f'input[data-testid="undefined-input-{i}"]', digit)
                await page.wait_for_timeout(100)
            
            await page.wait_for_timeout(3000)
            
            if "/home" in page.url or await page.query_selector('div[data-testid="agent-message-input"]'):
                print(f"[{account.id}] 登录成功")
                return True
            return False
            
        except Exception as e:
            print(f"[{account.id}] 登录失败: {e}")
            return False
    
    async def generate_video_single(self, page: Page, image_path: str, prompt: str, task_id: str) -> str | None:
        """单次视频生成（异步）"""
        try:
            await page.goto(self.HOME_URL)
            await page.wait_for_load_state("networkidle")
            await page.wait_for_timeout(2000)
            
            timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
            full_prompt = f"{self.PROMPT_PREFIX}{task_id}_{timestamp} {prompt}"
            
            input_div = page.locator('div[data-testid="agent-message-input"]')
            await input_div.click()
            await page.keyboard.type(full_prompt)
            await page.wait_for_timeout(500)
            
            async with page.expect_file_chooser() as fc_info:
                await page.click('button.rounded-full:has(svg path[d^="M16 1.1"])')
            file_chooser = await fc_info.value
            await file_chooser.set_files(image_path)
            await page.wait_for_timeout(2000)
            
            await page.keyboard.press("Enter")
            
            download_btn = 'button:has(svg path[d*="M7.858 2.023"])'
            await page.wait_for_selector(download_btn, timeout=600000)
            
            async with page.expect_download() as download_info:
                await page.click(download_btn)
            download = await download_info.value
            
            video_filename = f"{task_id}_{timestamp}.mp4"
            download_path = Path(self.config.get("output_dir", ".")) / video_filename
            await download.save_as(str(download_path))
            
            print(f"[{task_id}] 视频生成成功: {download_path}")
            return str(download_path)
            
        except Exception as e:
            print(f"[{task_id}] 视频生成失败: {e}")
            return None
    
    async def generate_videos_for_shot(
        self, ctx: BrowserContext, image_path: str, prompt: str, shot_id: str, count: int = 3
    ) -> list[str]:
        """
        为单个镜头并行生成多个视频
        - 在同一个浏览器上下文中开启多个 Tab 并行执行
        """
        pages = [await ctx.new_page() for _ in range(count)]
        
        # 并行执行所有生成任务
        tasks = [
            self.generate_video_single(page, image_path, prompt, f"{shot_id}_v{i+1}")
            for i, page in enumerate(pages)
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # 关闭页面
        for page in pages:
            await page.close()
        
        # 过滤成功结果
        return [r for r in results if isinstance(r, str)]


class AsyncFingerprintBrowser:
    """异步指纹浏览器管理器"""
    
    def __init__(self, account_id: str, fingerprint: dict = None):
        self.account_id = account_id
        self.fingerprint = fingerprint or self._generate_fingerprint()
        self.playwright = None
        self.browser = None
    
    def _generate_fingerprint(self) -> dict:
        import hashlib
        seed = hashlib.md5(self.account_id.encode()).hexdigest()
        return {
            "userAgent": f"Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.{int(seed[:4], 16) % 1000}.0",
            "viewport": {"width": 1920, "height": 1080},
            "locale": "zh-CN",
            "timezone_id": "Asia/Shanghai",
        }
    
    async def launch(self, headless: bool = False) -> BrowserContext:
        self.playwright = await async_playwright().start()
        self.browser = await self.playwright.chromium.launch(headless=headless)
        ctx = await self.browser.new_context(
            user_agent=self.fingerprint["userAgent"],
            viewport=self.fingerprint["viewport"],
            locale=self.fingerprint["locale"],
            timezone_id=self.fingerprint["timezone_id"],
        )
        return ctx
    
    async def close(self):
        if self.browser:
            await self.browser.close()
        if self.playwright:
            await self.playwright.stop()


class VideoGenerationScheduler:
    """
    视频生成调度器（支持双层并行）
    - 任务级并行：多个镜头同时处理（每个镜头分配一个账号）
    - 视频级并行：每个镜头同时生成 3 个视频
    """
    
    def __init__(self, config: dict):
        self.config = config
        self.account_pool = AccountPool(config.get("pool_file", "./account_pool.json"))
        self.email_receiver = EmailReceiver(
            imap_server=config["imap_server"],
            username=config["imap_username"],
            password=config["imap_password"],
        )
    
    async def process_single_shot(self, shot_data: dict) -> dict:
        """
        处理单个镜头（异步）
        shot_data: { shot_id, image_path, prompt, count }
        返回: { shot_id, videos: [...], error: None }
        """
        shot_id = shot_data["shot_id"]
        
        # 获取可用账号
        account = self.account_pool.get_available_account()
        if not account:
            return {"shot_id": shot_id, "videos": [], "error": "无可用账号"}
        
        automation = LovartAutomation(self.email_receiver, self.account_pool, self.config)
        browser = AsyncFingerprintBrowser(account.id)
        
        try:
            ctx = await browser.launch(headless=self.config.get("headless", False))
            
            # 先登录（使用第一个页面）
            login_page = await ctx.new_page()
            if not await automation.login_or_register(account, login_page):
                return {"shot_id": shot_id, "videos": [], "error": "登录失败"}
            await login_page.close()
            
            # 并行生成视频
            videos = await automation.generate_videos_for_shot(
                ctx=ctx,
                image_path=shot_data["image_path"],
                prompt=shot_data["prompt"],
                shot_id=shot_id,
                count=shot_data.get("count", 3)
            )
            
            # 标记账号使用
            self.account_pool.mark_used(account.id)
            
            return {"shot_id": shot_id, "videos": videos, "error": None}
            
        except Exception as e:
            return {"shot_id": shot_id, "videos": [], "error": str(e)}
        finally:
            await browser.close()
    
    async def process_multiple_shots(self, shots: list[dict], max_concurrent: int = 3) -> list[dict]:
        """
        并行处理多个镜头
        - shots: [{ shot_id, image_path, prompt, count }, ...]
        - max_concurrent: 最大并发镜头数（受限于可用账号数）
        """
        self.email_receiver.connect()
        
        try:
            # 使用 Semaphore 控制并发数
            semaphore = asyncio.Semaphore(max_concurrent)
            
            async def limited_task(shot_data):
                async with semaphore:
                    return await self.process_single_shot(shot_data)
            
            # 并行执行所有任务
            tasks = [limited_task(shot) for shot in shots]
            results = await asyncio.gather(*tasks)
            
            return results
            
        finally:
            self.email_receiver.close()
    
    def run(self, shots: list[dict], max_concurrent: int = 3) -> list[dict]:
        """同步入口，供外部调用"""
        return asyncio.run(self.process_multiple_shots(shots, max_concurrent))


# ========== 使用示例 ==========
if __name__ == "__main__":
    config = {
        "imap_server": "imap.gmail.com",
        "imap_username": "your-inbox@gmail.com",
        "imap_password": "your-app-password",
        "pool_file": "./account_pool.json",
        "output_dir": "./videos/",
        "prompt_prefix": "",
        "headless": False,
    }
    
    # 多个镜头任务
    shots = [
        {"shot_id": "shot_01", "image_path": "/path/to/img1.png", "prompt": "描述1", "count": 3},
        {"shot_id": "shot_02", "image_path": "/path/to/img2.png", "prompt": "描述2", "count": 3},
        {"shot_id": "shot_03", "image_path": "/path/to/img3.png", "prompt": "描述3", "count": 3},
    ]
    
    scheduler = VideoGenerationScheduler(config)
    
    # 并行处理：最多 3 个镜头同时处理，每个镜头同时生成 3 个视频
    results = scheduler.run(shots, max_concurrent=3)
    
    for r in results:
        print(f"镜头 {r['shot_id']}: {len(r['videos'])} 个视频, 错误: {r['error']}")
```

#### 4.3 配置文件示例

```json
{
  "imap_server": "imap.gmail.com",
  "imap_username": "your-inbox@gmail.com",
  "imap_password": "your-app-password",
  "pool_file": "./account_pool.json",
  "output_dir": "./workspaces/{id}/generated_xxx/videos/",
  "prompt_prefix": "生成一个高质量的短视频，",
  "headless": false,
  "videos_per_shot": 3
}
```

## 数据输入
- 工作区：`workspaces/{id}/generated_xxx/...`
- 选图：`selected_images.json` 中当前镜头对应的选中图片路径。
- 文本：镜头的视频描述字段，自动拼接前缀 `{镜头序号}_{时间戳}` 在最前方。

## 前端改动
- 镜头卡片视频描述右侧增加“生视频”按钮。  
- 点击后调用后端接口 `/automation/generate-video`，传参：`workspaceSlug`、`shotId`、`generatedDir`、`videoDescription`。  
- 按钮区：现有“供应商”按钮文案改为“生图供应商”，右侧新增“生视频配置”按钮，弹窗中可配置 headless/可见、生成数量（默认 3）、轮询间隔（默认 60s）、超时（默认 10–15 分钟）、可选代理/VPN。  
- 任务可见性：提交后在视频素材流插入占位卡片并显示状态“进行中”；按配置的轮询间隔调用自动化服务轮询 `/mine`，命中前缀后替换为真实视频；失败/超时在占位上展示错误并提供“重试”按钮。  
- 视频素材流：  
  - 展示/选择逻辑与图片素材流一致（同样的选中高亮/可取消）。  
  - 默认不再展示原片视频，列表仅展示生成的视频素材。  
  - 需从 `workspaces/{id}/generated_xxx/`（及子目录，如 `videos/`）加载对应镜头的视频并渲染。

## 后端/自动化服务
- 新增服务（示例路径）：`automation/video_generator.py`（或 TS/Node Playwright）。  
- 入参：工作区路径、镜头 ID、描述文本、图片路径、生成数量（固定 3）。  
- 可配置：headless/有头、代理/VPN、用户数据目录。  
- 产出：`workspaces/{id}/automation_logs/{taskId}/` 下保存 `input.json`、`browser.log`、步骤截图、`result.json`。  
- API：`POST /automation/generate-video`  
  - Body: `{ workspaceSlug, shotId, generatedDir, videoDescription }`  
  - 服务从 `selected_images.json` 解析图片绝对路径，执行上述自动化流程，返回 `taskId`。
- 下载落盘  
  - 保存路径：`workspaces/{id}/generated_xxx/`（可选子目录 `videos/`），文件名保留前缀（`{镜头序号}_{时间戳}.mp4`）。  
  - 成功后可选回写：将下载文件路径写入镜头数据（类似生图的 selected_images，需确定写入格式/文件位置），以便前端素材流加载。

## 配置与参数
- 运行模式：默认 headless，可切换可见模式调试（前端“生视频配置”弹窗可选）。
- 网络：可选代理/VPN（通过 Playwright `proxy` 或外部代理）。
- 生成数量：默认 3，可在前端配置。  
- 轮询：默认 60s 间隔，超时默认 10–15 分钟；匹配到前缀即判定完成并下载，可在前端配置。
- 超时与重试：整任务超时可配置，关键步骤（加载、上传、填文、点击）可各自重试。
- 并发：按镜头触发，需评估是否串行队列或并发限制；失败自动重试策略待定。
- 轮询策略：默认值可调整，是否采用退避策略待定。
- 上传/预览：若需等待上传预览完成再点生成，需在页面状态中判定（实测）。
- 存储：下载的视频保存至 `workspaces/{id}/generated_xxx/videos/{prefix}.mp4`（或实际扩展名），文件名带前缀便于回溯；日志仍存 `automation_logs/{taskId}`。

## 安全与凭证
- 若目标站需登录，支持复用用户数据目录或注入 Cookie（存放本地，不入仓库）。
- 登录态健壮：检测未登录/失效时弹提示，引导用户在可见模式完成登录后再执行；如存在验证码需人工处理。
- 不提交任何账号、Cookie、Token 到仓库。
 
## 监控与错误处理

- 前端显示提交结果；错误时弹出摘要。
- 后端记录 DOM/网络错误、截图；失败后可在日志目录中排查。
- 可选告警：通过飞书/钉钉/邮件发送任务失败通知（后续迭代）。

---

# 附录：方案二 - 海螺 AI（暂不实现）

> ⚠️ **状态：暂不实现**  
> 以下内容保留作为备选方案参考，当前优先使用 Lovart.ai 方案。

## 平台说明

- **目标网址**：`https://hailuoai.com/create/image-to-video`
- **我的作品**：`https://hailuoai.com/mine`

## 自动化步骤

1. **启动浏览器**
   - 可选：headless/有头、代理/VPN、复用用户数据目录（保登录态）。

2. **打开页面** `https://hailuoai.com/create/image-to-video`

3. **上传图片**
   - 定位"拖拽/粘贴/点击上传新图片"区域（含 SVG 与文字），上传 `selected_images.json` 中的图片文件。

4. **填写视频描述**
   - 定位 `#video-create-textarea`（contenteditable）写入视频描述。
   - 前缀格式：`{镜头序号}_{YYYYMMDDHHmmss}`，示例 `01_20251201110836`

5. **设置生成数量 = 3**
   - 操作 `ant-input-number` 控件：可直接设值为 3，或点击上箭头两次。

6. **点击生成**
   - 点击与数量控件联动的生成按钮（精确选择器需实测确认）。

7. **结果监控与下载**
   - 进入 `https://hailuoai.com/mine`，轮询生成列表。
   - 定位含有前缀 `{镜头序号}_{时间戳}` 的 `<span class="prompt-plain-span">` 文本，确认生成完成。
   - 匹配到后，触发下载（点击下载/导出按钮；下载按钮选择器需实测）。
   - 保存视频至 `workspaces/{id}/generated_xxx/videos/`，文件名保留前缀。

## 关键选择器（待实测）

| 元素 | 选择器 |
|------|--------|
| 视频描述输入框 | `#video-create-textarea` |
| 生成数量控件 | `.ant-input-number` |
| 生成按钮 | 待实测 |
| 作品列表项标题 | `span.prompt-plain-span` |
| 下载按钮 | 待实测 |
