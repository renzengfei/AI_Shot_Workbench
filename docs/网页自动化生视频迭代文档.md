# 网页自动化生视频迭代文档

## 目标场景
- 在人工改写界面（镜头卡片）的视频描述右侧新增"生视频"按钮。
- 点击后自动驱动 Chrome（可后台/可见，可配置）访问视频生成平台，完成图生视频任务。
- **主要方案**：Lovart.ai + 批量账号系统
- **备选方案**：海螺 AI（暂不实现，见文档末尾附录）

---

# 方案一：Lovart.ai + 批量账号系统（主要方案）

## 平台说明
- **目标网址**：`https://www.lovart.ai/canvas?projectId={id}&agent=1`
- **限制**：每个账号每天仅能生成 3 个视频
- **注册方式**：邮箱 + 验证码
- **应对策略**：批量注册账号，通过账号池轮换满足每日生产需求

## 批量账号系统架构

┌─────────────────────┐     ┌─────────────────────┐     ┌─────────────────────┐
│   邮箱系统           │     │   指纹浏览器         │     │   自动化引擎         │
│  (Catch-All+IMAP)   │────▶│  (Playwright注入)   │◀────│  (账号池调度)        │
└─────────────────────┘     └─────────────────────┘     └─────────────────────┘
         │                           │                           │
         ▼                           ▼                           ▼
   API获取验证码              每账号独立指纹               批量注册/生成调度

### 1. 邮箱系统：自建域名 + Cloudflare Catch-All + IMAP

#### 1.1 域名与邮件路由配置
1. **购买域名**（如 `yourvideobot.com`，约 $10/年）
2. **Cloudflare Email Routing 配置**：
   - 添加域名到 Cloudflare
   - 启用 Email Routing → 配置 Catch-All 规则
   - 所有 `*@yourvideobot.com` 邮件转发到一个主邮箱（如 Gmail）
3. **结果**：`user001@yourvideobot.com`、`user002@yourvideobot.com` 等无限邮箱地址

#### 1.2 IMAP 收件脚本
```python
# automation/email_receiver.py
import imaplib
import email
import re
import time

class EmailReceiver:
    def __init__(self, imap_server: str, username: str, password: str):
        self.imap_server = imap_server
        self.username = username
        self.password = password
    
    def connect(self):
        self.mail = imaplib.IMAP4_SSL(self.imap_server)
        self.mail.login(self.username, self.password)
        self.mail.select("inbox")
    
    def get_verification_code(self, target_email: str, timeout: int = 120) -> str | None:
        """获取发送到指定邮箱地址的验证码"""
        start_time = time.time()
        while time.time() - start_time < timeout:
            self.mail.recent()
            status, messages = self.mail.search(None, f'(TO "{target_email}")')
            if status != "OK":
                time.sleep(5)
                continue
            
            msg_ids = messages[0].split()
            if not msg_ids:
                time.sleep(5)
                continue
            
            latest_id = msg_ids[-1]
            status, msg_data = self.mail.fetch(latest_id, "(RFC822)")
            if status != "OK":
                continue
            
            raw_email = msg_data[0][1]
            msg = email.message_from_bytes(raw_email)
            body = self._get_body(msg)
            
            # 匹配验证码（4-6位数字）
            code_match = re.search(r'\b(\d{4,6})\b', body)
            if code_match:
                return code_match.group(1)
            
            time.sleep(5)
        return None
    
    def _get_body(self, msg) -> str:
        if msg.is_multipart():
            for part in msg.walk():
                if part.get_content_type() == "text/plain":
                    return part.get_payload(decode=True).decode('utf-8', errors='ignore')
        return msg.get_payload(decode=True).decode('utf-8', errors='ignore')
    
    def close(self):
        self.mail.logout()
```

### 2. 指纹浏览器：Playwright + 自建指纹注入

#### 2.1 指纹生成与注入
```python
# automation/fingerprint_browser.py
import random
import hashlib
from pathlib import Path
from playwright.sync_api import sync_playwright

def generate_fingerprint(seed: str) -> dict:
    """根据账号 ID 生成一致的指纹配置"""
    random.seed(hashlib.md5(seed.encode()).hexdigest())
    return {
        "userAgent": random.choice([
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
        ]),
        "platform": random.choice(["Win32", "MacIntel"]),
        "language": random.choice(["en-US", "zh-CN"]),
        "timezone": random.choice(["America/New_York", "Asia/Shanghai"]),
        "screen": {"width": random.choice([1920, 1680, 1440]), "height": random.choice([1080, 1050, 900])},
        "hardwareConcurrency": random.choice([4, 8, 12]),
        "deviceMemory": random.choice([4, 8, 16]),
        "webgl": {
            "vendor": random.choice(["Google Inc. (NVIDIA)", "Google Inc. (Intel)"]),
            "renderer": random.choice(["ANGLE (NVIDIA GeForce GTX 1080)", "ANGLE (Intel UHD Graphics 630)"]),
        },
        "canvasNoise": random.random() * 0.0001,
    }

INJECT_SCRIPT = """
(fp) => {
    Object.defineProperty(navigator, 'userAgent', { get: () => fp.userAgent });
    Object.defineProperty(navigator, 'platform', { get: () => fp.platform });
    Object.defineProperty(navigator, 'language', { get: () => fp.language });
    Object.defineProperty(navigator, 'hardwareConcurrency', { get: () => fp.hardwareConcurrency });
    Object.defineProperty(navigator, 'deviceMemory', { get: () => fp.deviceMemory });
    Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
    Object.defineProperty(screen, 'width', { get: () => fp.screen.width });
    Object.defineProperty(screen, 'height', { get: () => fp.screen.height });
    // WebGL
    const proxy = { apply: (t, a, args) => args[0]===37445?fp.webgl.vendor:args[0]===37446?fp.webgl.renderer:Reflect.apply(t,a,args) };
    WebGLRenderingContext.prototype.getParameter = new Proxy(WebGLRenderingContext.prototype.getParameter, proxy);
}
"""

class FingerprintBrowser:
    def __init__(self, account_id: str, profiles_dir: str = "./browser_profiles"):
        self.account_id = account_id
        self.profile_dir = Path(profiles_dir) / account_id
        self.profile_dir.mkdir(parents=True, exist_ok=True)
        self.fingerprint = generate_fingerprint(account_id)
    
    def launch(self, headless: bool = False):
        self.playwright = sync_playwright().start()
        self.context = self.playwright.chromium.launch_persistent_context(
            user_data_dir=str(self.profile_dir),
            headless=headless,
            args=['--disable-blink-features=AutomationControlled'],
            user_agent=self.fingerprint["userAgent"],
            viewport={"width": self.fingerprint["screen"]["width"], "height": self.fingerprint["screen"]["height"]},
            locale=self.fingerprint["language"],
            timezone_id=self.fingerprint["timezone"],
        )
        self.context.add_init_script(INJECT_SCRIPT, self.fingerprint)
        page = self.context.pages[0] if self.context.pages else self.context.new_page()
        return self.context, page
    
    def close(self):
        self.context.close()
        self.playwright.stop()
```

### 3. 账号池管理
```python
# automation/account_pool.py
import json
from datetime import date
from pathlib import Path
from dataclasses import dataclass, asdict

@dataclass
class Account:
    id: str
    email: str
    password: str
    registered: bool = False
    daily_usage: int = 0
    last_used_date: str = ""
    status: str = "active"

class AccountPool:
    DAILY_LIMIT = 3
    
    def __init__(self, pool_file: str = "./account_pool.json"):
        self.pool_file = Path(pool_file)
        self.accounts: dict[str, Account] = {}
        self._load()
    
    def _load(self):
        if self.pool_file.exists():
            data = json.loads(self.pool_file.read_text())
            self.accounts = {k: Account(**v) for k, v in data.items()}
    
    def _save(self):
        self.pool_file.write_text(json.dumps({k: asdict(v) for k, v in self.accounts.items()}, indent=2))
    
    def get_available_account(self):
        today = date.today().isoformat()
        for acc in self.accounts.values():
            if acc.status != "active" or not acc.registered:
                continue
            if acc.last_used_date != today:
                acc.daily_usage = 0
                acc.last_used_date = today
            if acc.daily_usage < self.DAILY_LIMIT:
                return acc
        return None
    
    def mark_used(self, account_id: str):
        acc = self.accounts.get(account_id)
        if acc:
            acc.daily_usage += 1
            acc.last_used_date = date.today().isoformat()
            self._save()
    
    def get_stats(self):
        today = date.today().isoformat()
        remaining = sum(
            max(0, self.DAILY_LIMIT - a.daily_usage) if a.last_used_date == today else self.DAILY_LIMIT
            for a in self.accounts.values() if a.registered and a.status == "active"
        )
        return {"total": len(self.accounts), "remaining_quota": remaining}
```

### 4. Lovart.ai 自动化流程（核心）

#### 4.1 关键选择器

| 功能 | 选择器 | 说明 |
|------|--------|------|
| 注册按钮 | `button:has(span.mantine-Button-label:text("注册"))` | 首页注册入口 |
| 邮箱输入框 | `input[type="email"]` | 邮箱输入 |
| Success 标识 | `#success-text` | 邮箱验证成功标识 |
| 继续按钮 | `button:has(span.mantine-Button-label:text("使用邮箱继续"))` | 点击继续登录 |
| 验证码输入框 | `input[data-testid="undefined-input-0"]` ~ `input[data-testid="undefined-input-5"]` | 6位验证码 |
| 视频描述输入框 | `div[data-testid="agent-message-input"]` | contenteditable |
| 附件上传按钮 | `button.rounded-full:has(svg path[d^="M16 1.1"])` | 回形针图标，上传图片 |
| 下载按钮 | `button:has(svg path[d*="M7.858 2.023"])` | 视频播放器上的下载 |

#### 4.2 自动化代码

```python
# automation/lovart_automation.py
import asyncio
import json
from pathlib import Path
from datetime import datetime

class LovartAutomation:
    BASE_URL = "https://www.lovart.ai/zh"
    HOME_URL = "https://www.lovart.ai/zh/home"
    
    # 可配置的视频描述前缀
    PROMPT_PREFIX = ""  # 从配置文件读取
    
    def __init__(self, email_receiver, account_pool, config: dict = None):
        self.email_receiver = email_receiver
        self.account_pool = account_pool
        self.config = config or {}
        self.PROMPT_PREFIX = self.config.get("prompt_prefix", "")
    
    def login_or_register(self, account, page) -> bool:
        """注册或登录流程（相同入口）"""
        try:
            # 1. 进入首页，点击注册按钮
            page.goto(self.BASE_URL)
            page.wait_for_load_state("networkidle")
            page.click('button:has(span.mantine-Button-label:text("注册"))')
            page.wait_for_timeout(1000)
            
            # 2. 输入邮箱
            page.fill('input[type="email"]', account.email)
            page.wait_for_timeout(500)
            
            # 3. 等待 Success! 出现
            page.wait_for_selector('#success-text', timeout=30000)
            
            # 4. 点击"使用邮箱继续"
            page.click('button:has(span.mantine-Button-label:text("使用邮箱继续"))')
            page.wait_for_timeout(2000)
            
            # 5. 获取验证码并输入
            code = self.email_receiver.get_verification_code(account.email, timeout=120)
            if not code or len(code) != 6:
                print(f"[{account.id}] 验证码获取失败或格式错误: {code}")
                return False
            
            # 6. 逐位填入验证码（6位）
            for i, digit in enumerate(code):
                page.fill(f'input[data-testid="undefined-input-{i}"]', digit)
                page.wait_for_timeout(100)
            
            # 7. 等待登录完成（URL 变化或页面元素出现）
            page.wait_for_timeout(3000)
            
            # 检查是否登录成功（通过 URL 或特定元素判断）
            if "/home" in page.url or page.query_selector('div[data-testid="agent-message-input"]'):
                print(f"[{account.id}] 登录成功")
                return True
            
            return False
            
        except Exception as e:
            print(f"[{account.id}] 登录/注册失败: {e}")
            return False
    
    def generate_video_single(self, page, image_path: str, prompt: str, shot_id: str) -> str | None:
        """单次生成视频任务"""
        try:
            # 1. 进入首页
            page.goto(self.HOME_URL)
            page.wait_for_load_state("networkidle")
            page.wait_for_timeout(2000)
            
            # 2. 构建完整提示词（前缀 + 时间戳 + 原始描述）
            timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
            full_prompt = f"{self.PROMPT_PREFIX}{shot_id}_{timestamp} {prompt}"
            
            # 3. 输入视频描述（contenteditable div）
            input_div = page.locator('div[data-testid="agent-message-input"]')
            input_div.click()
            page.keyboard.type(full_prompt)
            page.wait_for_timeout(500)
            
            # 4. 上传图片（回形针图标按钮）
            with page.expect_file_chooser() as fc_info:
                page.click('button.rounded-full:has(svg path[d^="M16 1.1"])')
            file_chooser = fc_info.value
            file_chooser.set_files(image_path)
            page.wait_for_timeout(2000)
            
            # 5. 按 Enter 发送（或点击发送按钮）
            page.keyboard.press("Enter")
            
            # 6. 等待任务完成（轮询下载按钮出现）
            # 设置超时 10 分钟
            download_btn_selector = 'button:has(svg path[d*="M7.858 2.023"])'
            page.wait_for_selector(download_btn_selector, timeout=600000)
            
            # 7. 点击下载
            with page.expect_download() as download_info:
                page.click(download_btn_selector)
            download = download_info.value
            
            # 8. 保存视频
            video_filename = f"{shot_id}_{timestamp}.mp4"
            download_path = Path(self.config.get("output_dir", ".")) / video_filename
            download.save_as(str(download_path))
            
            print(f"[{shot_id}] 视频生成成功: {download_path}")
            return str(download_path)
            
        except Exception as e:
            print(f"[{shot_id}] 视频生成失败: {e}")
            return None
    
    def generate_videos_for_shot(
        self,
        account,
        image_path: str,
        prompt: str,
        shot_id: str,
        count: int = 3,
        headless: bool = False
    ) -> list[str]:
        """
        为单个镜头生成多个视频（并行执行）
        - 同一账号并行执行 count 次
        - 返回生成的视频路径列表
        """
        browser = FingerprintBrowser(account.id)
        results = []
        
        try:
            # 创建多个页面并行执行
            ctx, main_page = browser.launch(headless)
            
            # 先登录
            if not self.login_or_register(account, main_page):
                return []
            
            # 并行创建多个任务
            pages = [main_page]
            for _ in range(count - 1):
                pages.append(ctx.new_page())
            
            # 并行执行生成任务
            # 注意：Playwright 同步 API 不支持真正并行，需要用 asyncio
            # 这里简化为串行执行，实际可改用 async API
            for i, page in enumerate(pages):
                result = self.generate_video_single(
                    page, image_path, prompt, f"{shot_id}_{i+1}"
                )
                if result:
                    results.append(result)
            
            # 标记账号使用（消耗积分）
            self.account_pool.mark_used(account.id)
            
        finally:
            browser.close()
        
        return results


class VideoGenerationScheduler:
    """视频生成调度器"""
    
    def __init__(self, config: dict):
        self.email_receiver = EmailReceiver(
            imap_server=config["imap_server"],
            username=config["imap_username"],
            password=config["imap_password"],
        )
        self.account_pool = AccountPool(config.get("pool_file", "./account_pool.json"))
        self.automation = LovartAutomation(
            self.email_receiver, 
            self.account_pool,
            config
        )
        self.config = config
    
    def process_shot(self, shot_data: dict) -> list[str]:
        """
        处理单个镜头的视频生成
        shot_data: { shot_id, image_path, prompt, count }
        """
        # 获取可用账号
        account = self.account_pool.get_available_account()
        if not account:
            stats = self.account_pool.get_stats()
            raise Exception(f"无可用账号，当日剩余配额: {stats['remaining_quota']}")
        
        self.email_receiver.connect()
        try:
            results = self.automation.generate_videos_for_shot(
                account=account,
                image_path=shot_data["image_path"],
                prompt=shot_data["prompt"],
                shot_id=shot_data["shot_id"],
                count=shot_data.get("count", 3),
                headless=self.config.get("headless", False)
            )
            return results
        finally:
            self.email_receiver.close()
    
    def load_selected_images(self, json_path: str) -> dict:
        """从 selected_images.json 加载首帧图路径"""
        with open(json_path, 'r') as f:
            return json.load(f)
```

#### 4.3 配置文件示例

```json
{
  "imap_server": "imap.gmail.com",
  "imap_username": "your-inbox@gmail.com",
  "imap_password": "your-app-password",
  "pool_file": "./account_pool.json",
  "output_dir": "./workspaces/{id}/generated_xxx/videos/",
  "prompt_prefix": "生成一个高质量的短视频，",
  "headless": false,
  "videos_per_shot": 3
}
```

## 数据输入
- 工作区：`workspaces/{id}/generated_xxx/...`
- 选图：`selected_images.json` 中当前镜头对应的选中图片路径。
- 文本：镜头的视频描述字段，自动拼接前缀 `{镜头序号}_{时间戳}` 在最前方。

## 前端改动
- 镜头卡片视频描述右侧增加“生视频”按钮。  
- 点击后调用后端接口 `/automation/generate-video`，传参：`workspaceSlug`、`shotId`、`generatedDir`、`videoDescription`。  
- 按钮区：现有“供应商”按钮文案改为“生图供应商”，右侧新增“生视频配置”按钮，弹窗中可配置 headless/可见、生成数量（默认 3）、轮询间隔（默认 60s）、超时（默认 10–15 分钟）、可选代理/VPN。  
- 任务可见性：提交后在视频素材流插入占位卡片并显示状态“进行中”；按配置的轮询间隔调用自动化服务轮询 `/mine`，命中前缀后替换为真实视频；失败/超时在占位上展示错误并提供“重试”按钮。  
- 视频素材流：  
  - 展示/选择逻辑与图片素材流一致（同样的选中高亮/可取消）。  
  - 默认不再展示原片视频，列表仅展示生成的视频素材。  
  - 需从 `workspaces/{id}/generated_xxx/`（及子目录，如 `videos/`）加载对应镜头的视频并渲染。

## 后端/自动化服务
- 新增服务（示例路径）：`automation/video_generator.py`（或 TS/Node Playwright）。  
- 入参：工作区路径、镜头 ID、描述文本、图片路径、生成数量（固定 3）。  
- 可配置：headless/有头、代理/VPN、用户数据目录。  
- 产出：`workspaces/{id}/automation_logs/{taskId}/` 下保存 `input.json`、`browser.log`、步骤截图、`result.json`。  
- API：`POST /automation/generate-video`  
  - Body: `{ workspaceSlug, shotId, generatedDir, videoDescription }`  
  - 服务从 `selected_images.json` 解析图片绝对路径，执行上述自动化流程，返回 `taskId`。
- 下载落盘  
  - 保存路径：`workspaces/{id}/generated_xxx/`（可选子目录 `videos/`），文件名保留前缀（`{镜头序号}_{时间戳}.mp4`）。  
  - 成功后可选回写：将下载文件路径写入镜头数据（类似生图的 selected_images，需确定写入格式/文件位置），以便前端素材流加载。

## 配置与参数
- 运行模式：默认 headless，可切换可见模式调试（前端“生视频配置”弹窗可选）。
- 网络：可选代理/VPN（通过 Playwright `proxy` 或外部代理）。
- 生成数量：默认 3，可在前端配置。  
- 轮询：默认 60s 间隔，超时默认 10–15 分钟；匹配到前缀即判定完成并下载，可在前端配置。
- 超时与重试：整任务超时可配置，关键步骤（加载、上传、填文、点击）可各自重试。
- 并发：按镜头触发，需评估是否串行队列或并发限制；失败自动重试策略待定。
- 轮询策略：默认值可调整，是否采用退避策略待定。
- 上传/预览：若需等待上传预览完成再点生成，需在页面状态中判定（实测）。
- 存储：下载的视频保存至 `workspaces/{id}/generated_xxx/videos/{prefix}.mp4`（或实际扩展名），文件名带前缀便于回溯；日志仍存 `automation_logs/{taskId}`。

## 安全与凭证
- 若目标站需登录，支持复用用户数据目录或注入 Cookie（存放本地，不入仓库）。
- 登录态健壮：检测未登录/失效时弹提示，引导用户在可见模式完成登录后再执行；如存在验证码需人工处理。
- 不提交任何账号、Cookie、Token 到仓库。
 
## 监控与错误处理

- 前端显示提交结果；错误时弹出摘要。
- 后端记录 DOM/网络错误、截图；失败后可在日志目录中排查。
- 可选告警：通过飞书/钉钉/邮件发送任务失败通知（后续迭代）。

---

# 附录：方案二 - 海螺 AI（暂不实现）

> ⚠️ **状态：暂不实现**  
> 以下内容保留作为备选方案参考，当前优先使用 Lovart.ai 方案。

## 平台说明

- **目标网址**：`https://hailuoai.com/create/image-to-video`
- **我的作品**：`https://hailuoai.com/mine`

## 自动化步骤

1. **启动浏览器**
   - 可选：headless/有头、代理/VPN、复用用户数据目录（保登录态）。

2. **打开页面** `https://hailuoai.com/create/image-to-video`

3. **上传图片**
   - 定位"拖拽/粘贴/点击上传新图片"区域（含 SVG 与文字），上传 `selected_images.json` 中的图片文件。

4. **填写视频描述**
   - 定位 `#video-create-textarea`（contenteditable）写入视频描述。
   - 前缀格式：`{镜头序号}_{YYYYMMDDHHmmss}`，示例 `01_20251201110836`

5. **设置生成数量 = 3**
   - 操作 `ant-input-number` 控件：可直接设值为 3，或点击上箭头两次。

6. **点击生成**
   - 点击与数量控件联动的生成按钮（精确选择器需实测确认）。

7. **结果监控与下载**
   - 进入 `https://hailuoai.com/mine`，轮询生成列表。
   - 定位含有前缀 `{镜头序号}_{时间戳}` 的 `<span class="prompt-plain-span">` 文本，确认生成完成。
   - 匹配到后，触发下载（点击下载/导出按钮；下载按钮选择器需实测）。
   - 保存视频至 `workspaces/{id}/generated_xxx/videos/`，文件名保留前缀。

## 关键选择器（待实测）

| 元素 | 选择器 |
|------|--------|
| 视频描述输入框 | `#video-create-textarea` |
| 生成数量控件 | `.ant-input-number` |
| 生成按钮 | 待实测 |
| 作品列表项标题 | `span.prompt-plain-span` |
| 下载按钮 | 待实测 |
