# 生图模型供应商切换需求文档

## 1. 背景
目前 `AI_Shot_Workbench` 的生图功能仅支持单一供应商（代号“兔子”）。为了扩展生图能力，需要支持在界面上切换不同的生图模型供应商，并新增对“糖果”供应商的支持。

## 2. 核心需求
1.  **多供应商支持**：系统需支持配置和管理多个生图供应商。
2.  **界面切换**：用户应能在界面上方便地切换当前使用的生图供应商。
3.  **参数配置**：不同供应商需要不同的配置参数（如 API Key、模型名称、接口地址等）。
4.  **新增“糖果”供应商**：集成“糖果”供应商的生图接口。

## 3. 配置作用域说明 (Configuration Scope)
针对用户关于“不同工作空间是否共享配置”的疑问，设计如下：

1.  **供应商定义 (Global)**：
    *   **作用域**：全局共享。
    *   **内容**：供应商列表及其详细配置（如 API Key, Endpoint, Model Name）。
    *   **理由**：避免用户在每个工作空间重复输入相同的 API Key。
    *   **存储**：建议存储在用户主目录下的配置文件中 (e.g., `~/.ai_shot_workbench/config.json`) 或数据库的全局表中。

2.  **当前使用的供应商 (Workspace-specific)**：
    *   **作用域**：工作空间独立。
    *   **内容**：当前工作空间选中的供应商 ID (Provider ID)。
    *   **理由**：允许用户在“项目A”使用 Rabbit 模型，而在“项目B”使用 Candy 模型，互不干扰。
    *   **存储**：存储在工作空间的 `project.json` 文件中 (新增字段 `active_image_provider_id`)。
    *   **默认行为**：新建工作空间时，默认使用全局设置中标记为“默认”的供应商。

## 4. 供应商详情

### 3.1. 兔子供应商 (Rabbit) - 当前使用
*   **状态**：已实现
*   **代码位置**：`AI_Shot_Workbench/backend/main.py` -> `generate_images_internal` 函数
*   **配置项**：
    *   `Base URL`: 默认为 `https://api.tu-zi.com/v1` (环境变量 `GEMINI_IMAGE_BASE_URL`)
    *   `API Key`: (环境变量 `GEMINI_IMAGE_API_KEY`)
    *   `Model`: 默认为 `gemini-3-pro-image-preview-4` (环境变量 `GEMINI_IMAGE_MODEL`)
*   **协议**：OpenAI 兼容格式 (`/chat/completions`)
    *   Payload 结构：
        ```json
        {
            "model": "...",
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": "..."},
                        {"type": "image_url", "image_url": {"url": "..."}}
                    ]
                }
            ],
            "stream": true
        }
        ```

### 3.2. 糖果供应商 (Candy) - 新增需求
*   **状态**：待开发
*   **参考代码**：`开发/画镜/apps/api/services/nano_client.py` (NanoClient)
*   **配置项**：
    *   `Endpoint`: 请求地址
    *   `API Key`: 鉴权密钥
    *   `Model`: 模型名称
*   **协议**：自定义 Nano 协议
    *   **请求头**：
        *   `Content-Type`: `application/json`
        *   `Authorization`: `Bearer {api_key}`
    *   **Payload 结构** (参考 `build_nano_messages`):
        ```json
        {
            "extra_body": {
                "imageConfig": {
                    "aspectRatio": "9:16" // 或其他比例
                }
            },
            "model": "...",
            "messages": [
                {
                    "role": "system",
                    "content": "{\"imageConfig\": {\"aspectRatio\": \"9:16\"}}"
                },
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": "提示词..."},
                        // 可选：参考图
                        {"type": "image_url", "image_url": {"url": "..."}}
                    ]
                }
            ],
            "max_tokens": 150,
            "temperature": 0.7
        }
        ```
    *   **特殊处理**：
        *   Prompt 预处理：需去除 `<think>` 标签和模块占位符。
        *   Full Bleed 提示词：建议自动追加“画面需充满画布...”等提示词以保证质量。
        *   响应解析：需兼容 JSON 字符串、OpenAI 风格富文本等多种返回格式来提取 `imageUrl`。

## 4. 功能设计建议

### 4.1. 后端改造
*   抽象 `ImageProvider` 接口，定义统一的 `generate_image` 方法。
*   实现 `RabbitProvider` 和 `CandyProvider` 类。
*   在 `GenerateImageRequest` 中增加 `provider` 字段（或从全局设置获取）。
*   配置存储：建议将供应商配置（API Key 等）持久化存储（如 JSON 文件或数据库），而非仅依赖环境变量，以便用户在 UI 修改。

### 4.2. 前端改造
*   **设置页面**：新增“生图模型设置”面板。
    *   允许添加/编辑/删除供应商配置。
    *   字段：供应商类型（下拉选择 Rabbit/Candy）、名称（自定义）、API Key、Base URL/Endpoint、Model Name。
*   **生图面板**：增加“供应商切换”下拉框，从已配置的列表中选择。

### 4.3. 前端交互设计 (详细)

#### 4.3.1. 入口位置
*   **位置**：`Step6_ImageGen.tsx` 页面顶部标题栏右侧。
*   **样式**：新增一个“设置”按钮（图标：`Settings` / `Gear`），置于“下一步”按钮左侧或作为独立的功能区。
*   **交互**：点击按钮弹出“生图模型配置”模态框 (Modal)。

#### 4.3.2. 模态框 (Modal) 交互
模态框需包含以下两个主要视图：

**视图 A：供应商列表 (默认视图)**
1.  **列表展示**：显示所有已配置的供应商卡片。
    *   每张卡片显示：供应商名称（如“我的兔子”）、类型图标（Rabbit/Candy）、当前状态（是否激活）。
    *   **激活状态**：使用单选框 (Radio) 或高亮边框标识当前正在使用的供应商。
2.  **操作按钮**：
    *   **新增**：底部或右上角提供“+ 添加供应商”按钮。
    *   **编辑**：每张卡片提供“编辑”按钮（铅笔图标）。
    *   **删除**：每张卡片提供“删除”按钮（垃圾桶图标），需二次确认。
3.  **底部栏**：包含“关闭”按钮。

**视图 B：添加/编辑供应商 (表单视图)**
1.  **表单字段**：
    *   **供应商类型**：下拉选择 (Select)，选项包括 `Rabbit` (默认)、`Candy`。
    *   **名称**：输入框 (Input)，用户自定义显示名称，如“公司内部Rabbit”。
    *   **API Key**：密码输入框 (Password Input)，支持显示/隐藏切换。
    *   **Endpoint / Base URL**：输入框 (Input)，API 请求地址。
    *   **模型名称 (Model)**：输入框 (Input)，如 `gemini-3-pro` 或 `flux-schnell`。
2.  **验证**：
    *   必填项校验。
    *   (可选) “测试连接”按钮，发送一个简单的 Ping 或 Dry-run 请求验证配置有效性。
3.  **操作按钮**：
    *   **保存**：保存配置并返回列表视图。
    *   **取消**：放弃修改并返回列表视图。

#### 4.3.3. 状态反馈
*   切换供应商后，界面应有 Toast 提示“已切换至 [供应商名称]”。
*   生图失败时，错误提示中应包含当前使用的供应商名称，便于排查。

## 5. 兼容性与迁移 (Compatibility & Migration)

### 5.1. 环境变量兼容
*   **优先级**：UI 配置 > 环境变量。
*   **初始化**：系统首次启动时，若检测到 `GEMINI_IMAGE_API_KEY` 等环境变量，应自动创建一个默认的 "Rabbit (Env)" 供应商配置，确保现有功能不受影响。

### 5.2. 概念区分
*   **Image Provider (生图供应商)**：指后端服务提供方（如 Rabbit, Candy），决定了**谁**来生成图片。
*   **Image Preset (生图设定)**：指提示词模板（如“电影质感”、“二次元”），决定了生成图片的**风格**。
*   **关系**：两者是正交的。用户可以在使用 "Rabbit" 供应商时选择 "电影质感" 设定，也可以在使用 "Candy" 供应商时选择同样的设定。

## 6. 注意事项
*   **安全性**：API Key 等敏感信息在前端展示时应脱敏，存储时注意安全。
*   **流式响应**：Rabbit 接口目前使用了流式响应 (`stream=True`)，Candy 接口参考代码中使用的是非流式 (`httpx.post`)，需确认 Candy 是否支持流式，或后端统一封装为流式/非流式返回给前端。
*   **错误处理**：不同供应商的错误码和错误信息格式不同，需统一异常处理逻辑。

## 6. 附录：糖果供应商参考代码 (NanoClient)

以下是 `开发/画镜/apps/api/services/nano_client.py` 的完整代码，供开发参考：

```python
from __future__ import annotations

import io
import json
import re
from typing import Dict, List, Optional

import httpx
from PIL import Image


def strip_think_blocks(text: Optional[str]) -> str:
    if not text:
        return ""
    try:
        return (
            str(text)
            .replace("</think>", "")
            .replace("<think>", "")
        )
    except Exception:
        return str(text or "")


def strip_module_placeholders(text: Optional[str]) -> str:
    if not text:
        return ""
    try:
        t = str(text)
        t = re.sub(r"<[^>]+>", "", t)
        t = re.sub(r"\{[^}]+\}", "", t)
        t = re.sub(r"[\s\n]{2,}", "\n", t)
        return t.strip()
    except Exception:
        return str(text or "")


def build_nano_messages(
    prompt: str,
    *,
    aspect_ratio: str = "9:16",
    global_negative: str = "",
    reference_data_url: Optional[str] = None,
    enforce_full_bleed: bool = True,
) -> List[Dict]:
    system_content = json.dumps({"imageConfig": {"aspectRatio": aspect_ratio}}, ensure_ascii=False)
    user_parts: List[Dict] = []
    main_text = strip_module_placeholders(strip_think_blocks(prompt or ""))
    if main_text:
        user_parts.append({"type": "text", "text": main_text})
    if enforce_full_bleed:
        user_parts.append({
            "type": "text",
            "text": "画面需充满画布（full-bleed，edge-to-edge），禁止任何边框、留白、相框/海报外框、黑白描边；允许主体被裁切，不要求完整人物；禁止自动外延或补全画面外内容。"
        })
    if global_negative:
        user_parts.append({"type": "text", "text": f"请严格避免以下特征：\n{global_negative}"})
    # 可选：附带参考图（以 dataURL 形式）
    if reference_data_url:
        user_parts.append({
            "type": "image_url",
            "image_url": {"url": reference_data_url},
        })

    return [
        {"role": "system", "content": system_content},
        {"role": "user", "content": user_parts},
    ]


def parse_image_url_from_markdown(content: str) -> Optional[str]:
    """优先解析 Markdown 图片 URL，若不存在则回退到任意 http(s) URL（尽量挑图片）。"""
    if not content or not isinstance(content, str):
        return None
    # 1) Markdown 图片
    m = re.search(r"!\[image\]\((https?://[^)]+)\)", content)
    if m:
        return m.group(1)
    # 2) 明文图片 URL（带扩展名优先）
    m2 = re.search(r"(https?://[^\s)]+\.(?:png|jpe?g|webp|gif))", content, re.IGNORECASE)
    if m2:
        return m2.group(1)
    # 3) data:image/*;base64
    m3 = re.search(r"(data:image/[^;]+;base64,[A-Za-z0-9+/=]+)", content)
    if m3:
        return m3.group(1)
    # 4) 任意 http(s) URL（退而求其次）
    m4 = re.search(r"(https?://[^\s)]+)", content)
    if m4:
        return m4.group(1)
    return None


class NanoClient:
    def __init__(self, *, endpoint: str, api_key: str, model: str, timeout: float = 60.0):
        self.endpoint = endpoint.rstrip("/")
        self.api_key = api_key
        self.model = model
        self.timeout = timeout

    def generate_image_url(
        self,
        prompt: str,
        *,
        aspect_ratio: str = "9:16",
        max_tokens: int = 150,
        temperature: float = 0.7,
        global_negative: str = "",
        reference_data_url: Optional[str] = None,
        enforce_full_bleed: bool = True,
    ) -> Dict[str, str]:
        messages = build_nano_messages(
            prompt,
            aspect_ratio=aspect_ratio,
            global_negative=global_negative,
            reference_data_url=reference_data_url,
            enforce_full_bleed=enforce_full_bleed,
        )
        body = {
            "extra_body": {"imageConfig": {"aspectRatio": aspect_ratio}},
            "model": self.model,
            "messages": messages,
            "max_tokens": int(max_tokens),
            "temperature": float(temperature),
        }

        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key}",
        }

        def _do_request():
            return httpx.post(self.endpoint, headers=headers, json=body, timeout=self.timeout)

        # First attempt
        try:
            res = _do_request()
        except Exception as e:
            # network error: retry once
            res = _do_request()

        if res.status_code == 429:
            # backoff then retry once
            try:
                import time
                time.sleep(0.6)
            except Exception:
                pass
            res = _do_request()

        if not res.is_success:
            msg = res.reason_phrase
            try:
                data = res.json()
                msg = data.get("error", {}).get("message", msg)
            except Exception:
                pass
            if res.status_code in (401, 403):
                msg = f"{msg}（请检查 API Key 权限/有效期）"
            raise RuntimeError(f"API错误: {msg}")

        data = res.json()
        # 兼容多种返回形态
        msg = (((data or {}).get("choices") or [{}])[0] or {}).get("message", {})
        content = msg.get("content", "")
        url: Optional[str] = None
        # a) content 为字符串
        if isinstance(content, str):
            # 尝试 JSON 字符串里包含 imageUrl
            try:
                maybe = json.loads(content)
                if isinstance(maybe, dict) and isinstance(maybe.get("imageUrl"), str):
                    url = maybe.get("imageUrl")
            except Exception:
                pass
            if not url:
                url = parse_image_url_from_markdown(content)
        # b) content 为列表（OpenAI 风格富文本）
        elif isinstance(content, list):
            for part in content:
                if isinstance(part, dict):
                    if part.get("type") == "image_url":
                        u = ((part.get("image_url") or {}).get("url"))
                        if isinstance(u, str):
                            url = u
                            break
                    # 纯文本里也尝试解析
                    if part.get("type") == "text" and isinstance(part.get("text"), str):
                        u2 = parse_image_url_from_markdown(part.get("text"))
                        if u2:
                            url = u2
                            break
        # c) 顶层容器直接有 imageUrl（保险）
        if not url and isinstance(data, dict) and isinstance(data.get("imageUrl"), str):
            url = data.get("imageUrl")
        if not url:
            raise RuntimeError("无法从响应中提取图像URL")
        # 提供复用信息
        effective_prompt = []
        try:
            # 拿到发出去的 user 文本（便于写回）
            parts = messages[1].get("content") or []
            for p in parts:
                if (p or {}).get("type") == "text":
                    effective_prompt.append(p.get("text") or "")
        except Exception:
            pass
        return {"image_url": url, "effective_prompt": "\n---\n".join([t for t in effective_prompt if t])}

    def fetch_image_and_convert_png(self, url: str) -> bytes:
        # data URL 直接解码
        if url.startswith("data:image/"):
            import base64
            try:
                b64 = url.split(",", 1)[1]
            except Exception:
                raise RuntimeError("无效的 data:image URL")
            raw = base64.b64decode(b64)
            src = io.BytesIO(raw)
        else:
            r = httpx.get(url, timeout=self.timeout)
            r.raise_for_status()
            src = io.BytesIO(r.content)
        # 转为 PNG，避免扩展名与内容不一致
        with Image.open(src) as im:
            im = im.convert("RGB")
            out = io.BytesIO()
            im.save(out, format="PNG")
            return out.getvalue()
```

